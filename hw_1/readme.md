# Линейная регрессия предсказания стоимости автомобиля с инференсом

## EDA

Произведены:
- предобработка признаков, удаление дубликатов, заполнение пропусков;
- анализ корреляции признаков с таргетом и друг с другом (рассчитаны корреляции Пирсона и Спирмена, phik);
- построены попарные диаграммы рассеивания для вещественных признаков, боксплоты таргета с группировкой внутри категориальных признаков.

Результат — удалось очистить и привести вещественные признаки в нужный формат. Выдвинули гипотезы о характере связи признаков с таргетом (пригодится при фиче инжиниринге). Оставили все признаки в датасете, так как все они предположительно влияют на таргет.

## Обучение и выбор модели

### Линейная регрессия на вещественных признаках

На этом этапе:
- обучили классическую линейную регрессию с дефолтными параметрами — R^2 test: 0.601, MSE test: 229640125449 (+ проделали ручную реализацию R^2 и adjusted R^2);
- стандартизировали значения и переобучили модель — качество не изменилось;
- обучили Lasso-регрессию, зануления весов не произошло, качество не изменилось; 
- попробовали подобрать гиперпарамеры для Lasso-регрессии через GridSearchCV — на лучшей модели качество осталось тем же;
- обучили ElasticNet регрессию с подбором гиперпараметров — результаты еще ниже предыдущих (R^2 test: 0.598, MSE test: 231021529856);
- попробовали применить к классической регресси самописную L0 регуляризацию, модель продемонстрировала те же результаты, что и простая линейная регрессия с первого этапа.

Только на вещественных признаках, несмотря на все улучшения, не вышло добиться приемлемого качества для модели. Фиксируем 0.601, MSE test: 229640125449 как лучший результат.

### Линейная регрессия с добавлением категориальных признаков

- предобработали name оставив только марку авто (чтобы пойти в OHE с не слишком большим числом категорий;
- закодировали категориальные признаки при помощи One Hot Encoding;
- обучили Ridge-регрессию на закодированных категориальных и стандартизированных вещественных признаках, сразу с подбором гиперпараметра.

Получили скачок в качестве на этом этапе — R^2 test: 0.783, MSE test: 124762359538. Категориальные фичи оказались значимыми для решения нашей задачи. Остановились на сетапе с использованием всех признаков.

**Feature Engineering**

Еще немного покрутили признаки модели, а именно:
1) Пробовала добавить новые признаки — возраст и пробег км в год, но качество становилось хуже, чем с одним доп признаком power_per_liter.
2) Попыталась прологарифмировать km_driven — не дало улучшений, но получила качество выше с логарифмом engine.
3) Год все-таки связан с таргетом гиперболической зависимостью, качество модели лучше, чем на квадрате.
4) Категориальную переменную owner можно представить в виде вещественной ранговой. Test Drive Car присваиваем самое высокое значение. С точки зрения бизнес-смысла чем меньше ранг, тем более привлекательное / дорогое авто, а авто, не бывшее во владении у частника, всегда оценивается рынком ниже. Заодно избавились от необходимости кодировать признак и снизили число независимых переменных (на нашем небольшом датасете дало буст в качестве).
5) По-другому предобработала name. На первом шаге оставила только марку автомобиля. В этот раз обучила модель на категории brand + model.
6) Пробовала удалять выбросы (самые экстремальные значения) — получила снижение в качестве. Сделала реализацию замены выбросов на граничные значения, подобрала квантили, которые дают наилучшее качество итоговой модели — 0.15 и 0.85.

Для экспериментов каждого из этапов обучала модель заново и сравнивала качество. Если оно не улучшалось / падало — откатывалась на предыдущий этап и продолжала эксперименты.
Все описанные изменения помогли получить метрики R^2 test: 0.906, MSE test: 53848457411. Лучшая модель по качеству.

*Что не получилось сделать*

Была идея через api подтянуть кузов автомобиля (седан, хэтчбек, минивэн и т.д.), в рамках одной и той же марки-модели они могут оказывать влияние на качество. Однако в датасете много автомобилей, рассчитанных на рынок Индии, которых не было среди данных бесплатных источников. Получив на тестовом семпле большую часть пустых ответов решила не продолжать реализацию шага.

### Бизнес-метрики

Для принятия решения, с какой моделью пойдем в реализацию сервиса, посчитали для всех обученных моделей следующие метрики:
- долю верно предсказанных цен (+/- 10% от реального значения)
- долю заниженных предсказаний среди верно предсказанных
- долю отрицательного отклонения в абсолютном объеме ошибки (+mae, чтобы понимать этот абсолют).

Ridge-регрессия до фиче инжиниринга и после стали лидерами не только по качеству, но и по бизнес-метрикам.

Метрики Ridge-регрессии на базовых фичах (в соответствии с порядком из списка выше):
- 0.305
- 0.492
- 0.571 (при mae 165613.552)

Метрики Ridge-регрессии на новых фичах:
- 0.297
- 0.508
- 0.546 (при mae 125641.308)

С учетом сильного прироста по качеству для сервиса решила брать последнюю модель после фиче инжиниринга.

## Сервис

Сервис состоит из 2-х .py файлов:
- preprocessing, в котором храняся все методы предобработки (форматирование, заполнение пропусков), а также стандартизация и энкодинг
- app — основной файл сервиса, который принимает входящий запрос, валидирует входные данные, вызывает сначала препроцессинг, а протом придикшн цены по обученным весам.

Содержание app.py:
- эндпоинт predict_item работает с одним входящим объектом в формате словаря и возвращает предсказанную цену в response;
- эндпоинт predict_items принимает на вход csv-таблицу с объектами и их признаками, и возвращает также csv-таблицу с одним доп столбцом, в котором лежат предсказания для каждого объекта.

Программы обращаются к следующим файлам.

В preprocessing.py:
- scaler.pkl — обученный стандартизатор для вещественных признаков;
- onehot_encoder.pkl — обученный энкодер для категориальных признаков;
- dict_medians.pkl — медианы вещественных признаков, рассчитанные на трейне, для заполнения пропусков в переменных входных объектов;
- owner_rank_mapping.pkl — словарь для замены категориального признака owner на вещественный ранг.

В app.py:
- model.pkl — веса обученной модели, по которым осуществляется предсказание после препроцессинга.

*Комментарий*
Немного изменила структуру типа данных входного класса. У нас в тесте встречались пропуски, поэтому добавила необязательность признаков для тех критериев, в которых они встречались при обучении (и следовательно обработку пропусков в препроцессинге для них).

### Демо работы сервиса
- скриншоты для эндпоинта predict_item (один входящий объект) 
https://drive.google.com/drive/folders/1we00TxyVt1jrktZhLKOgAH8knXltQwMB?usp=sharing
- скриншоты для эндпоинта predict_items (csv файл)
https://drive.google.com/drive/folders/1ifplz7gfFa4lppDPdbmnjxIfV_TK9WxQ?usp=sharing 
- скринкаст записи работы сервиса
https://drive.google.com/file/d/1yThNic8HuvfpNn8RNnRyvM4ipYGiaEYg/view?usp=sharing

Корневая папка материалов демо
https://drive.google.com/drive/folders/1U1XZocg1AyhMU_5Cr4IRUL0zMvN3UsJY?usp=sharing

